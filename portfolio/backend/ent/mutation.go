// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"portfolio/ent/portfolio"
	"portfolio/ent/predicate"
	"portfolio/ent/report"
	"portfolio/schema"
	"sync"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypePortfolio = "Portfolio"
	TypeReport    = "Report"
)

// PortfolioMutation represents an operation that mutates the Portfolio nodes in the graph.
type PortfolioMutation struct {
	config
	op                Op
	typ               string
	id                *int
	request_id        *string
	job               *string
	career_years      *uint
	addcareer_years   *int
	tech_stacks       *[]string
	appendtech_stacks []string
	projects          *[]schema.Project
	appendprojects    []schema.Project
	preferred_company *string
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*Portfolio, error)
	predicates        []predicate.Portfolio
}

var _ ent.Mutation = (*PortfolioMutation)(nil)

// portfolioOption allows management of the mutation configuration using functional options.
type portfolioOption func(*PortfolioMutation)

// newPortfolioMutation creates new mutation for the Portfolio entity.
func newPortfolioMutation(c config, op Op, opts ...portfolioOption) *PortfolioMutation {
	m := &PortfolioMutation{
		config:        c,
		op:            op,
		typ:           TypePortfolio,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPortfolioID sets the ID field of the mutation.
func withPortfolioID(id int) portfolioOption {
	return func(m *PortfolioMutation) {
		var (
			err   error
			once  sync.Once
			value *Portfolio
		)
		m.oldValue = func(ctx context.Context) (*Portfolio, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Portfolio.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPortfolio sets the old Portfolio of the mutation.
func withPortfolio(node *Portfolio) portfolioOption {
	return func(m *PortfolioMutation) {
		m.oldValue = func(context.Context) (*Portfolio, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PortfolioMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PortfolioMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PortfolioMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PortfolioMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Portfolio.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRequestID sets the "request_id" field.
func (m *PortfolioMutation) SetRequestID(s string) {
	m.request_id = &s
}

// RequestID returns the value of the "request_id" field in the mutation.
func (m *PortfolioMutation) RequestID() (r string, exists bool) {
	v := m.request_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestID returns the old "request_id" field's value of the Portfolio entity.
// If the Portfolio object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PortfolioMutation) OldRequestID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestID: %w", err)
	}
	return oldValue.RequestID, nil
}

// ResetRequestID resets all changes to the "request_id" field.
func (m *PortfolioMutation) ResetRequestID() {
	m.request_id = nil
}

// SetJob sets the "job" field.
func (m *PortfolioMutation) SetJob(s string) {
	m.job = &s
}

// Job returns the value of the "job" field in the mutation.
func (m *PortfolioMutation) Job() (r string, exists bool) {
	v := m.job
	if v == nil {
		return
	}
	return *v, true
}

// OldJob returns the old "job" field's value of the Portfolio entity.
// If the Portfolio object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PortfolioMutation) OldJob(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJob is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJob requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJob: %w", err)
	}
	return oldValue.Job, nil
}

// ResetJob resets all changes to the "job" field.
func (m *PortfolioMutation) ResetJob() {
	m.job = nil
}

// SetCareerYears sets the "career_years" field.
func (m *PortfolioMutation) SetCareerYears(u uint) {
	m.career_years = &u
	m.addcareer_years = nil
}

// CareerYears returns the value of the "career_years" field in the mutation.
func (m *PortfolioMutation) CareerYears() (r uint, exists bool) {
	v := m.career_years
	if v == nil {
		return
	}
	return *v, true
}

// OldCareerYears returns the old "career_years" field's value of the Portfolio entity.
// If the Portfolio object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PortfolioMutation) OldCareerYears(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCareerYears is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCareerYears requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCareerYears: %w", err)
	}
	return oldValue.CareerYears, nil
}

// AddCareerYears adds u to the "career_years" field.
func (m *PortfolioMutation) AddCareerYears(u int) {
	if m.addcareer_years != nil {
		*m.addcareer_years += u
	} else {
		m.addcareer_years = &u
	}
}

// AddedCareerYears returns the value that was added to the "career_years" field in this mutation.
func (m *PortfolioMutation) AddedCareerYears() (r int, exists bool) {
	v := m.addcareer_years
	if v == nil {
		return
	}
	return *v, true
}

// ResetCareerYears resets all changes to the "career_years" field.
func (m *PortfolioMutation) ResetCareerYears() {
	m.career_years = nil
	m.addcareer_years = nil
}

// SetTechStacks sets the "tech_stacks" field.
func (m *PortfolioMutation) SetTechStacks(s []string) {
	m.tech_stacks = &s
	m.appendtech_stacks = nil
}

// TechStacks returns the value of the "tech_stacks" field in the mutation.
func (m *PortfolioMutation) TechStacks() (r []string, exists bool) {
	v := m.tech_stacks
	if v == nil {
		return
	}
	return *v, true
}

// OldTechStacks returns the old "tech_stacks" field's value of the Portfolio entity.
// If the Portfolio object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PortfolioMutation) OldTechStacks(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTechStacks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTechStacks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTechStacks: %w", err)
	}
	return oldValue.TechStacks, nil
}

// AppendTechStacks adds s to the "tech_stacks" field.
func (m *PortfolioMutation) AppendTechStacks(s []string) {
	m.appendtech_stacks = append(m.appendtech_stacks, s...)
}

// AppendedTechStacks returns the list of values that were appended to the "tech_stacks" field in this mutation.
func (m *PortfolioMutation) AppendedTechStacks() ([]string, bool) {
	if len(m.appendtech_stacks) == 0 {
		return nil, false
	}
	return m.appendtech_stacks, true
}

// ResetTechStacks resets all changes to the "tech_stacks" field.
func (m *PortfolioMutation) ResetTechStacks() {
	m.tech_stacks = nil
	m.appendtech_stacks = nil
}

// SetProjects sets the "projects" field.
func (m *PortfolioMutation) SetProjects(s []schema.Project) {
	m.projects = &s
	m.appendprojects = nil
}

// Projects returns the value of the "projects" field in the mutation.
func (m *PortfolioMutation) Projects() (r []schema.Project, exists bool) {
	v := m.projects
	if v == nil {
		return
	}
	return *v, true
}

// OldProjects returns the old "projects" field's value of the Portfolio entity.
// If the Portfolio object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PortfolioMutation) OldProjects(ctx context.Context) (v []schema.Project, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjects is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjects requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjects: %w", err)
	}
	return oldValue.Projects, nil
}

// AppendProjects adds s to the "projects" field.
func (m *PortfolioMutation) AppendProjects(s []schema.Project) {
	m.appendprojects = append(m.appendprojects, s...)
}

// AppendedProjects returns the list of values that were appended to the "projects" field in this mutation.
func (m *PortfolioMutation) AppendedProjects() ([]schema.Project, bool) {
	if len(m.appendprojects) == 0 {
		return nil, false
	}
	return m.appendprojects, true
}

// ResetProjects resets all changes to the "projects" field.
func (m *PortfolioMutation) ResetProjects() {
	m.projects = nil
	m.appendprojects = nil
}

// SetPreferredCompany sets the "preferred_company" field.
func (m *PortfolioMutation) SetPreferredCompany(s string) {
	m.preferred_company = &s
}

// PreferredCompany returns the value of the "preferred_company" field in the mutation.
func (m *PortfolioMutation) PreferredCompany() (r string, exists bool) {
	v := m.preferred_company
	if v == nil {
		return
	}
	return *v, true
}

// OldPreferredCompany returns the old "preferred_company" field's value of the Portfolio entity.
// If the Portfolio object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PortfolioMutation) OldPreferredCompany(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPreferredCompany is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPreferredCompany requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPreferredCompany: %w", err)
	}
	return oldValue.PreferredCompany, nil
}

// ClearPreferredCompany clears the value of the "preferred_company" field.
func (m *PortfolioMutation) ClearPreferredCompany() {
	m.preferred_company = nil
	m.clearedFields[portfolio.FieldPreferredCompany] = struct{}{}
}

// PreferredCompanyCleared returns if the "preferred_company" field was cleared in this mutation.
func (m *PortfolioMutation) PreferredCompanyCleared() bool {
	_, ok := m.clearedFields[portfolio.FieldPreferredCompany]
	return ok
}

// ResetPreferredCompany resets all changes to the "preferred_company" field.
func (m *PortfolioMutation) ResetPreferredCompany() {
	m.preferred_company = nil
	delete(m.clearedFields, portfolio.FieldPreferredCompany)
}

// Where appends a list predicates to the PortfolioMutation builder.
func (m *PortfolioMutation) Where(ps ...predicate.Portfolio) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PortfolioMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PortfolioMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Portfolio, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PortfolioMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PortfolioMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Portfolio).
func (m *PortfolioMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PortfolioMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.request_id != nil {
		fields = append(fields, portfolio.FieldRequestID)
	}
	if m.job != nil {
		fields = append(fields, portfolio.FieldJob)
	}
	if m.career_years != nil {
		fields = append(fields, portfolio.FieldCareerYears)
	}
	if m.tech_stacks != nil {
		fields = append(fields, portfolio.FieldTechStacks)
	}
	if m.projects != nil {
		fields = append(fields, portfolio.FieldProjects)
	}
	if m.preferred_company != nil {
		fields = append(fields, portfolio.FieldPreferredCompany)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PortfolioMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case portfolio.FieldRequestID:
		return m.RequestID()
	case portfolio.FieldJob:
		return m.Job()
	case portfolio.FieldCareerYears:
		return m.CareerYears()
	case portfolio.FieldTechStacks:
		return m.TechStacks()
	case portfolio.FieldProjects:
		return m.Projects()
	case portfolio.FieldPreferredCompany:
		return m.PreferredCompany()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PortfolioMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case portfolio.FieldRequestID:
		return m.OldRequestID(ctx)
	case portfolio.FieldJob:
		return m.OldJob(ctx)
	case portfolio.FieldCareerYears:
		return m.OldCareerYears(ctx)
	case portfolio.FieldTechStacks:
		return m.OldTechStacks(ctx)
	case portfolio.FieldProjects:
		return m.OldProjects(ctx)
	case portfolio.FieldPreferredCompany:
		return m.OldPreferredCompany(ctx)
	}
	return nil, fmt.Errorf("unknown Portfolio field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PortfolioMutation) SetField(name string, value ent.Value) error {
	switch name {
	case portfolio.FieldRequestID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestID(v)
		return nil
	case portfolio.FieldJob:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJob(v)
		return nil
	case portfolio.FieldCareerYears:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCareerYears(v)
		return nil
	case portfolio.FieldTechStacks:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTechStacks(v)
		return nil
	case portfolio.FieldProjects:
		v, ok := value.([]schema.Project)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjects(v)
		return nil
	case portfolio.FieldPreferredCompany:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPreferredCompany(v)
		return nil
	}
	return fmt.Errorf("unknown Portfolio field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PortfolioMutation) AddedFields() []string {
	var fields []string
	if m.addcareer_years != nil {
		fields = append(fields, portfolio.FieldCareerYears)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PortfolioMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case portfolio.FieldCareerYears:
		return m.AddedCareerYears()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PortfolioMutation) AddField(name string, value ent.Value) error {
	switch name {
	case portfolio.FieldCareerYears:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCareerYears(v)
		return nil
	}
	return fmt.Errorf("unknown Portfolio numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PortfolioMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(portfolio.FieldPreferredCompany) {
		fields = append(fields, portfolio.FieldPreferredCompany)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PortfolioMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PortfolioMutation) ClearField(name string) error {
	switch name {
	case portfolio.FieldPreferredCompany:
		m.ClearPreferredCompany()
		return nil
	}
	return fmt.Errorf("unknown Portfolio nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PortfolioMutation) ResetField(name string) error {
	switch name {
	case portfolio.FieldRequestID:
		m.ResetRequestID()
		return nil
	case portfolio.FieldJob:
		m.ResetJob()
		return nil
	case portfolio.FieldCareerYears:
		m.ResetCareerYears()
		return nil
	case portfolio.FieldTechStacks:
		m.ResetTechStacks()
		return nil
	case portfolio.FieldProjects:
		m.ResetProjects()
		return nil
	case portfolio.FieldPreferredCompany:
		m.ResetPreferredCompany()
		return nil
	}
	return fmt.Errorf("unknown Portfolio field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PortfolioMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PortfolioMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PortfolioMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PortfolioMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PortfolioMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PortfolioMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PortfolioMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Portfolio unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PortfolioMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Portfolio edge %s", name)
}

// ReportMutation represents an operation that mutates the Report nodes in the graph.
type ReportMutation struct {
	config
	op                               Op
	typ                              string
	id                               *int
	request_id                       *string
	status                           *string
	project_feedbacks                *[]schema.Feedback
	appendproject_feedbacks          []schema.Feedback
	tech_stack_feedbacks             *[]schema.Feedback
	appendtech_stack_feedbacks       []schema.Feedback
	project_recommendations          *[]schema.Recommendation
	appendproject_recommendations    []schema.Recommendation
	tech_stack_recommendations       *[]schema.Recommendation
	appendtech_stack_recommendations []schema.Recommendation
	clearedFields                    map[string]struct{}
	done                             bool
	oldValue                         func(context.Context) (*Report, error)
	predicates                       []predicate.Report
}

var _ ent.Mutation = (*ReportMutation)(nil)

// reportOption allows management of the mutation configuration using functional options.
type reportOption func(*ReportMutation)

// newReportMutation creates new mutation for the Report entity.
func newReportMutation(c config, op Op, opts ...reportOption) *ReportMutation {
	m := &ReportMutation{
		config:        c,
		op:            op,
		typ:           TypeReport,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withReportID sets the ID field of the mutation.
func withReportID(id int) reportOption {
	return func(m *ReportMutation) {
		var (
			err   error
			once  sync.Once
			value *Report
		)
		m.oldValue = func(ctx context.Context) (*Report, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Report.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withReport sets the old Report of the mutation.
func withReport(node *Report) reportOption {
	return func(m *ReportMutation) {
		m.oldValue = func(context.Context) (*Report, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ReportMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ReportMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ReportMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ReportMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Report.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRequestID sets the "request_id" field.
func (m *ReportMutation) SetRequestID(s string) {
	m.request_id = &s
}

// RequestID returns the value of the "request_id" field in the mutation.
func (m *ReportMutation) RequestID() (r string, exists bool) {
	v := m.request_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestID returns the old "request_id" field's value of the Report entity.
// If the Report object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportMutation) OldRequestID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestID: %w", err)
	}
	return oldValue.RequestID, nil
}

// ResetRequestID resets all changes to the "request_id" field.
func (m *ReportMutation) ResetRequestID() {
	m.request_id = nil
}

// SetStatus sets the "status" field.
func (m *ReportMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *ReportMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Report entity.
// If the Report object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ReportMutation) ResetStatus() {
	m.status = nil
}

// SetProjectFeedbacks sets the "project_feedbacks" field.
func (m *ReportMutation) SetProjectFeedbacks(s []schema.Feedback) {
	m.project_feedbacks = &s
	m.appendproject_feedbacks = nil
}

// ProjectFeedbacks returns the value of the "project_feedbacks" field in the mutation.
func (m *ReportMutation) ProjectFeedbacks() (r []schema.Feedback, exists bool) {
	v := m.project_feedbacks
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectFeedbacks returns the old "project_feedbacks" field's value of the Report entity.
// If the Report object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportMutation) OldProjectFeedbacks(ctx context.Context) (v []schema.Feedback, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectFeedbacks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectFeedbacks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectFeedbacks: %w", err)
	}
	return oldValue.ProjectFeedbacks, nil
}

// AppendProjectFeedbacks adds s to the "project_feedbacks" field.
func (m *ReportMutation) AppendProjectFeedbacks(s []schema.Feedback) {
	m.appendproject_feedbacks = append(m.appendproject_feedbacks, s...)
}

// AppendedProjectFeedbacks returns the list of values that were appended to the "project_feedbacks" field in this mutation.
func (m *ReportMutation) AppendedProjectFeedbacks() ([]schema.Feedback, bool) {
	if len(m.appendproject_feedbacks) == 0 {
		return nil, false
	}
	return m.appendproject_feedbacks, true
}

// ResetProjectFeedbacks resets all changes to the "project_feedbacks" field.
func (m *ReportMutation) ResetProjectFeedbacks() {
	m.project_feedbacks = nil
	m.appendproject_feedbacks = nil
}

// SetTechStackFeedbacks sets the "tech_stack_feedbacks" field.
func (m *ReportMutation) SetTechStackFeedbacks(s []schema.Feedback) {
	m.tech_stack_feedbacks = &s
	m.appendtech_stack_feedbacks = nil
}

// TechStackFeedbacks returns the value of the "tech_stack_feedbacks" field in the mutation.
func (m *ReportMutation) TechStackFeedbacks() (r []schema.Feedback, exists bool) {
	v := m.tech_stack_feedbacks
	if v == nil {
		return
	}
	return *v, true
}

// OldTechStackFeedbacks returns the old "tech_stack_feedbacks" field's value of the Report entity.
// If the Report object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportMutation) OldTechStackFeedbacks(ctx context.Context) (v []schema.Feedback, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTechStackFeedbacks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTechStackFeedbacks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTechStackFeedbacks: %w", err)
	}
	return oldValue.TechStackFeedbacks, nil
}

// AppendTechStackFeedbacks adds s to the "tech_stack_feedbacks" field.
func (m *ReportMutation) AppendTechStackFeedbacks(s []schema.Feedback) {
	m.appendtech_stack_feedbacks = append(m.appendtech_stack_feedbacks, s...)
}

// AppendedTechStackFeedbacks returns the list of values that were appended to the "tech_stack_feedbacks" field in this mutation.
func (m *ReportMutation) AppendedTechStackFeedbacks() ([]schema.Feedback, bool) {
	if len(m.appendtech_stack_feedbacks) == 0 {
		return nil, false
	}
	return m.appendtech_stack_feedbacks, true
}

// ResetTechStackFeedbacks resets all changes to the "tech_stack_feedbacks" field.
func (m *ReportMutation) ResetTechStackFeedbacks() {
	m.tech_stack_feedbacks = nil
	m.appendtech_stack_feedbacks = nil
}

// SetProjectRecommendations sets the "project_recommendations" field.
func (m *ReportMutation) SetProjectRecommendations(s []schema.Recommendation) {
	m.project_recommendations = &s
	m.appendproject_recommendations = nil
}

// ProjectRecommendations returns the value of the "project_recommendations" field in the mutation.
func (m *ReportMutation) ProjectRecommendations() (r []schema.Recommendation, exists bool) {
	v := m.project_recommendations
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectRecommendations returns the old "project_recommendations" field's value of the Report entity.
// If the Report object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportMutation) OldProjectRecommendations(ctx context.Context) (v []schema.Recommendation, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectRecommendations is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectRecommendations requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectRecommendations: %w", err)
	}
	return oldValue.ProjectRecommendations, nil
}

// AppendProjectRecommendations adds s to the "project_recommendations" field.
func (m *ReportMutation) AppendProjectRecommendations(s []schema.Recommendation) {
	m.appendproject_recommendations = append(m.appendproject_recommendations, s...)
}

// AppendedProjectRecommendations returns the list of values that were appended to the "project_recommendations" field in this mutation.
func (m *ReportMutation) AppendedProjectRecommendations() ([]schema.Recommendation, bool) {
	if len(m.appendproject_recommendations) == 0 {
		return nil, false
	}
	return m.appendproject_recommendations, true
}

// ResetProjectRecommendations resets all changes to the "project_recommendations" field.
func (m *ReportMutation) ResetProjectRecommendations() {
	m.project_recommendations = nil
	m.appendproject_recommendations = nil
}

// SetTechStackRecommendations sets the "tech_stack_recommendations" field.
func (m *ReportMutation) SetTechStackRecommendations(s []schema.Recommendation) {
	m.tech_stack_recommendations = &s
	m.appendtech_stack_recommendations = nil
}

// TechStackRecommendations returns the value of the "tech_stack_recommendations" field in the mutation.
func (m *ReportMutation) TechStackRecommendations() (r []schema.Recommendation, exists bool) {
	v := m.tech_stack_recommendations
	if v == nil {
		return
	}
	return *v, true
}

// OldTechStackRecommendations returns the old "tech_stack_recommendations" field's value of the Report entity.
// If the Report object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportMutation) OldTechStackRecommendations(ctx context.Context) (v []schema.Recommendation, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTechStackRecommendations is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTechStackRecommendations requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTechStackRecommendations: %w", err)
	}
	return oldValue.TechStackRecommendations, nil
}

// AppendTechStackRecommendations adds s to the "tech_stack_recommendations" field.
func (m *ReportMutation) AppendTechStackRecommendations(s []schema.Recommendation) {
	m.appendtech_stack_recommendations = append(m.appendtech_stack_recommendations, s...)
}

// AppendedTechStackRecommendations returns the list of values that were appended to the "tech_stack_recommendations" field in this mutation.
func (m *ReportMutation) AppendedTechStackRecommendations() ([]schema.Recommendation, bool) {
	if len(m.appendtech_stack_recommendations) == 0 {
		return nil, false
	}
	return m.appendtech_stack_recommendations, true
}

// ResetTechStackRecommendations resets all changes to the "tech_stack_recommendations" field.
func (m *ReportMutation) ResetTechStackRecommendations() {
	m.tech_stack_recommendations = nil
	m.appendtech_stack_recommendations = nil
}

// Where appends a list predicates to the ReportMutation builder.
func (m *ReportMutation) Where(ps ...predicate.Report) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ReportMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ReportMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Report, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ReportMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ReportMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Report).
func (m *ReportMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ReportMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.request_id != nil {
		fields = append(fields, report.FieldRequestID)
	}
	if m.status != nil {
		fields = append(fields, report.FieldStatus)
	}
	if m.project_feedbacks != nil {
		fields = append(fields, report.FieldProjectFeedbacks)
	}
	if m.tech_stack_feedbacks != nil {
		fields = append(fields, report.FieldTechStackFeedbacks)
	}
	if m.project_recommendations != nil {
		fields = append(fields, report.FieldProjectRecommendations)
	}
	if m.tech_stack_recommendations != nil {
		fields = append(fields, report.FieldTechStackRecommendations)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ReportMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case report.FieldRequestID:
		return m.RequestID()
	case report.FieldStatus:
		return m.Status()
	case report.FieldProjectFeedbacks:
		return m.ProjectFeedbacks()
	case report.FieldTechStackFeedbacks:
		return m.TechStackFeedbacks()
	case report.FieldProjectRecommendations:
		return m.ProjectRecommendations()
	case report.FieldTechStackRecommendations:
		return m.TechStackRecommendations()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ReportMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case report.FieldRequestID:
		return m.OldRequestID(ctx)
	case report.FieldStatus:
		return m.OldStatus(ctx)
	case report.FieldProjectFeedbacks:
		return m.OldProjectFeedbacks(ctx)
	case report.FieldTechStackFeedbacks:
		return m.OldTechStackFeedbacks(ctx)
	case report.FieldProjectRecommendations:
		return m.OldProjectRecommendations(ctx)
	case report.FieldTechStackRecommendations:
		return m.OldTechStackRecommendations(ctx)
	}
	return nil, fmt.Errorf("unknown Report field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReportMutation) SetField(name string, value ent.Value) error {
	switch name {
	case report.FieldRequestID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestID(v)
		return nil
	case report.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case report.FieldProjectFeedbacks:
		v, ok := value.([]schema.Feedback)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectFeedbacks(v)
		return nil
	case report.FieldTechStackFeedbacks:
		v, ok := value.([]schema.Feedback)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTechStackFeedbacks(v)
		return nil
	case report.FieldProjectRecommendations:
		v, ok := value.([]schema.Recommendation)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectRecommendations(v)
		return nil
	case report.FieldTechStackRecommendations:
		v, ok := value.([]schema.Recommendation)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTechStackRecommendations(v)
		return nil
	}
	return fmt.Errorf("unknown Report field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ReportMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ReportMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReportMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Report numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ReportMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ReportMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ReportMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Report nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ReportMutation) ResetField(name string) error {
	switch name {
	case report.FieldRequestID:
		m.ResetRequestID()
		return nil
	case report.FieldStatus:
		m.ResetStatus()
		return nil
	case report.FieldProjectFeedbacks:
		m.ResetProjectFeedbacks()
		return nil
	case report.FieldTechStackFeedbacks:
		m.ResetTechStackFeedbacks()
		return nil
	case report.FieldProjectRecommendations:
		m.ResetProjectRecommendations()
		return nil
	case report.FieldTechStackRecommendations:
		m.ResetTechStackRecommendations()
		return nil
	}
	return fmt.Errorf("unknown Report field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ReportMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ReportMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ReportMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ReportMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ReportMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ReportMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ReportMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Report unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ReportMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Report edge %s", name)
}
